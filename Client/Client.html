<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="client.css">
  <title>Document</title>
</head>
<body>
  
  <div>
    <!-- buttons for choosing colours -->
    <form>
      <label>red</label>
      <input type="radio" id="colourButtonsRed" name="colour" value="red" class="redButton" onclick = "update_object_colour('red')" checked="checked">
      <label>green</label>
      <input type="radio" id="colourButtonsGreen" name="colour" value="green" class="greenButton" onclick = "update_object_colour('green')"> 
      <label>blue</label>
      <input type="radio" id="colourButtonsBlue" name="colour" value="blue" class="blueButton" onclick = "update_object_colour('blue')"> 
    </form>
  </div>
  <div id = "gridDiv"> 
    <!-- The grid of circles -->
    <svg id="grid1" style = "position: center; display: block; margin: auto;">
        <defs>
          <!-- arrowhead marker definition -->
          <marker id="arrowhead" viewBox="0 0 10 10" refX="5" refY="5"
              markerWidth="2%" markerHeight="2%"
              orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" />
          </marker>
        </defs>
      <rect id="rect1" style="fill:rgb(37, 37, 37);stroke:black;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9" />
    </svg>
  </div>

  <script>
    "use strict";
    //-------------------------------------------Style options--------------------------------------------
    //options for the rectangle for the grid
    let rectWidth = 97, rectHeight = 97, rectBorderRadius = 8, rectVariable;
    //options for the grid of circles
    let gridHeight = 5, gridWidth = 5,
        gridCircRadius = "8.5%", gridStroke = "black", gridStrokeWidth = "2", gridFill = "white",
        gridCircMargin = 13, gridCircDistance = (100-(gridCircMargin*2))/4; //spaces circles evenly, centered in the rectangle

    //options for drawn password
    let passwordDotRadius = 2,
        passwordArrowWidth = 1;



    //-------------------------------------Grid creation + password input event listeners-------------------------------------------
    //other variables
    let htmlGrid = document.getElementById("grid1")
    let i = 0, j = 0;
    let temporaryElement, tempX = 0, tempY = 0;


    //Gets viewport dimensions
    let vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    let vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    let gridSize = Math.min(vw, vh) * 0.5;
    let gridOffsetXY = [];
    gridOffsetXY[0] = (vw/2) - (gridSize/2);
    gridOffsetXY[1] = (vh/2) - (gridSize/2);

    //Used to debugging viewport dimensions
    console.log("Width: " + vw + " Height: " + vh);

    //Changes password grid Size based on viewport
    htmlGrid.style.width = gridSize;
    htmlGrid.style.height = gridSize;

    //sets the grid's rectangle's style
    rectVariable = document.getElementById("rect1");
    tempX = (100-rectWidth)/2;
    tempY = (100-rectHeight)/2;
    rectVariable.style.x = tempX + "%";
    rectVariable.style.y = tempY + "%";
    rectVariable.style.width = rectWidth + "%";
    rectVariable.style.height = rectHeight + "%";
    rectVariable.style.rx = rectBorderRadius + "%";
    rectVariable.style.ry = rectBorderRadius + "%";

    //generates circles and names them "circle i j" with the i and j coordinates from 0 to 4
    for(i = 0; i < gridHeight; i++) {
      for(j = 0; j < gridWidth; j++) {
        //creates element
        temporaryElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");

        //assigns placement, size and style
        tempX = (gridCircMargin+(gridCircDistance*j));
        tempY = (gridCircMargin+(gridCircDistance*i));
        temporaryElement.style.cx = tempX + "%";
        temporaryElement.style.cy = tempY + "%";
        temporaryElement.style.r = gridCircRadius;
        temporaryElement.style.stroke = gridStroke;
        temporaryElement.style["stroke-width"] = gridStrokeWidth;
        temporaryElement.style.fill = gridFill;

        //assigns ID and actions
        temporaryElement.id = "circle " + j + " " + i;
        temporaryElement.addEventListener("mouseover", function mouse_over(inputEvent){ 
          update_password_input(inputEvent, "hover"); 
        });
        temporaryElement.addEventListener("mousedown", function mouse_over(inputEvent){ 
          update_password_input(inputEvent, "press"); 
        });
        temporaryElement.addEventListener("mouseup", function mouse_over(inputEvent){ 
          update_password_input(inputEvent, "release"); 
        });

        //appends to the grid
        htmlGrid.appendChild(temporaryElement);
      }
    }
    //missing:
    //dynamic scaling of password grid based on viewport change




    //---------------------------------------------Password input functionality---------------------------------------------
    //variables
    let clickInputData = [], connectedInputData = [], clickInputNodes = 0, connectedInputNodes = 0;
    let passwordData = [], passwordObjects = 0;
    let currentColour = "red";
    let lastDrawnPasswordObjects = 0; //keeps track of how many objects have been drawn in draw_password
    let tempDrawnPasswordData = [], tempDrawnPasswordNodes = 0; //keeps track of drawing in draw_object
    let mousePosXY = [0, 0];
    let tempChild;
    let tempX1 = 0, tempY1 = 0, tempX2 = 0, tempY2 = 0;
    let tempXoffset = 0, tempYoffset = 0;
    i = 0;

    //updates object colour
    function update_object_colour(inputColour) {
      currentColour = inputColour;
    }

    //draws the object you're currently drawing
    function draw_object() {
      let tempX = 0, tempY = 0;
    
      //Only draw a point/arrow if there are click input nodes used
      if(connectedInputNodes > 1) {
        //draw connected lines
        //If there is an arrow/point, delete it
        if(tempDrawnPasswordNodes > 0 && tempDrawnPasswordData[0][1].id == "tempObjectArrow") {
          tempDrawnPasswordData[0][0].parentNode.removeChild(tempDrawnPasswordData[0][0]);
          tempDrawnPasswordData[0][1].parentNode.removeChild(tempDrawnPasswordData[0][1]);
          tempDrawnPasswordNodes = 0;
          tempDrawnPasswordData = [];
        }
        //do the connected lines drawing
        for(i = tempDrawnPasswordNodes; i <= connectedInputNodes; ++i) {
          //Make an arrow
          if(tempDrawnPasswordNodes != connectedInputNodes) { //only draw from start if it hasn't been drawn already
            tempDrawnPasswordData[tempDrawnPasswordNodes] = [];
            tempDrawnPasswordData[tempDrawnPasswordNodes][1] = document.createElementNS("http://www.w3.org/2000/svg", "line");
            //set the first coordinate, in percentage within the grid
            tempX1 = (gridCircMargin+(gridCircDistance*connectedInputData[tempDrawnPasswordNodes].id[7]));
            tempY1 = (gridCircMargin+(gridCircDistance*connectedInputData[tempDrawnPasswordNodes].id[9]));
            tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('x1', tempX1 + "%");
            tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('y1', tempY1 + "%");
            //set the second coordinate, in pixel coordinates within the viewport
            tempX2 = (mousePosXY[0]-gridOffsetXY[0]);
            tempY2 = (mousePosXY[1]-gridOffsetXY[1]);
            tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('x2', tempX2);
            tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('y2', tempY2);
            //set other values
            tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('stroke-width', gridStrokeWidth + "%");
            tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('stroke', currentColour);
            tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('marker-end', "url(#arrowhead)");
            tempDrawnPasswordData[tempDrawnPasswordNodes][1].classList.add("noclick");
            tempDrawnPasswordData[0][1].id = "tempObjectConnected";
            htmlGrid.appendChild(tempDrawnPasswordData[tempDrawnPasswordNodes][1]);
            //only increase the number of nodes when drawing a new line
            ++tempDrawnPasswordNodes;
          } else if(tempDrawnPasswordNodes != 0) { //if it has been drawn, update its end placement and previous lines end placement
            //make the arrow 20% shorter than the distance to the cursor
            //change the current lines 2nd coordinate, again in pixel coordinates within the viewport
            tempX2 = (mousePosXY[0]-gridOffsetXY[0]);
            tempY2 = (mousePosXY[1]-gridOffsetXY[1]);
            tempDrawnPasswordData[tempDrawnPasswordNodes-1][1].setAttribute('x2', tempX2);
            tempDrawnPasswordData[tempDrawnPasswordNodes-1][1].setAttribute('y2', tempY2);  
            //set the prior lines second coordinate, in percentage within the grid
            tempX2 = (gridCircMargin+(gridCircDistance*connectedInputData[tempDrawnPasswordNodes-1].id[7]));
            tempY2 = (gridCircMargin+(gridCircDistance*connectedInputData[tempDrawnPasswordNodes-1].id[9]));
            tempDrawnPasswordData[tempDrawnPasswordNodes-2][1].setAttribute('x2', tempX2 + "%");
            tempDrawnPasswordData[tempDrawnPasswordNodes-2][1].setAttribute('y2', tempY2 + "%");
            //update the prior line to not be an arrow
            tempDrawnPasswordData[tempDrawnPasswordNodes-2][1].setAttribute('marker-end', "");
          }
        }
      } else {
        //draw point/arrow
        //draw a gray point and a gray arrow, since we don't know which it will end up being
        //---first the point
        tempDrawnPasswordData[tempDrawnPasswordNodes] = [];
        if(tempDrawnPasswordNodes != clickInputNodes) { //only draw if it hasn't been drawn already
          tempDrawnPasswordData[tempDrawnPasswordNodes][0] = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          tempDrawnPasswordData[tempDrawnPasswordNodes][0].style.r = passwordDotRadius + "%";
          tempDrawnPasswordData[tempDrawnPasswordNodes][0].style.fill = currentColour;
          tempX = (gridCircMargin+(gridCircDistance*clickInputData[tempDrawnPasswordNodes].id[7]));
          tempY = (gridCircMargin+(gridCircDistance*clickInputData[tempDrawnPasswordNodes].id[9]));
          tempDrawnPasswordData[tempDrawnPasswordNodes][0].style.cx = tempX + "%";
          tempDrawnPasswordData[tempDrawnPasswordNodes][0].style.cy = tempY + "%";
          tempDrawnPasswordData[tempDrawnPasswordNodes][0].classList.add("noclick");
          htmlGrid.appendChild(tempDrawnPasswordData[tempDrawnPasswordNodes][0]);
        }
        //---then the arrow
        if(tempDrawnPasswordNodes != clickInputNodes) { //only draw from start if it hasn't been drawn already
          tempDrawnPasswordData[tempDrawnPasswordNodes][1] = document.createElementNS("http://www.w3.org/2000/svg", "line");
          //set the first coordinate, in percentage within the grid
          tempX1 = (gridCircMargin+(gridCircDistance*clickInputData[tempDrawnPasswordNodes].id[7]));
          tempY1 = (gridCircMargin+(gridCircDistance*clickInputData[tempDrawnPasswordNodes].id[9]));
          tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('x1', tempX1 + "%");
          tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('y1', tempY1 + "%");
          //set the second coordinate, in pixel coordinates within the viewport
          tempX2 = (mousePosXY[0]-gridOffsetXY[0]);
          tempY2 = (mousePosXY[1]-gridOffsetXY[1]);
          tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('x2', tempX2);
          tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('y2', tempY2);
          //set other values
          tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('stroke-width', gridStrokeWidth + "%");
          tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('stroke', currentColour);
          tempDrawnPasswordData[tempDrawnPasswordNodes][1].setAttribute('marker-end', "url(#arrowhead)");
          tempDrawnPasswordData[tempDrawnPasswordNodes][1].classList.add("noclick");
          tempDrawnPasswordData[tempDrawnPasswordNodes][1].id = "tempObjectArrow";
          htmlGrid.appendChild(tempDrawnPasswordData[tempDrawnPasswordNodes][1]);
          //only increase the number of nodes when drawing a new line
          ++tempDrawnPasswordNodes;
        } else if(tempDrawnPasswordNodes != 0) { //if it has been drawn, update its end placement
          //change the 2nd coordinate, again in pixel coordinates within the viewport
          tempX2 = (mousePosXY[0]-gridOffsetXY[0]);
          tempY2 = (mousePosXY[1]-gridOffsetXY[1]);
          tempDrawnPasswordData[tempDrawnPasswordNodes-1][1].setAttribute('x2', tempX2);
          tempDrawnPasswordData[tempDrawnPasswordNodes-1][1].setAttribute('y2', tempY2);  
        }
      }
    }
    function clear_input(){
      let i;
      for(i = 0; i < tempDrawnPasswordNodes; ++i) {
        if(tempDrawnPasswordData[0][1].id == "tempObjectArrow") {
          tempDrawnPasswordData[i][0].parentNode.removeChild(tempDrawnPasswordData[i][0]);
        }
        tempDrawnPasswordData[i][1].parentNode.removeChild(tempDrawnPasswordData[i][1]);
      }
      tempDrawnPasswordNodes = 0;
      tempDrawnPasswordData = [];
      clickInputData = [];
      clickInputNodes = 0;
      connectedInputData = [];
      connectedInputNodes = 0;
    }

    //draws the password objects that have been completed
    function draw_password() {
      let tempLength = 0, tempRotation = 0;
      let tempX1 = 0, tempY1 = 0,
          tempX2 = 0, tempY2 = 0;
      let tempSlope1 = 0, tempSlope2 = 0, 
          tempHeight = 0,
          tempIntersectX = 0, tempIntersectY = 0,
          tempFinalX = 0, tempFinalY = 0,
          finalX = 0, finalY = 0;
      let i = 0, j = 0;
      //start at the number of drawn objects to avoid re-drawing them
      for(i = lastDrawnPasswordObjects; i < passwordObjects; ++i) {
        //find out if it's a point, arrow or connected lines
        if(passwordData[i].type === "connected lines") {
          //draw connected lines
          for(j = 0; j < passwordData[i].IDs.length-1; ++j) {
            //draw a line
            temporaryElement = document.createElementNS("http://www.w3.org/2000/svg", "line");
            tempX1 = (gridCircMargin+(gridCircDistance*passwordData[i].IDs[j][7]));
            tempY1 = (gridCircMargin+(gridCircDistance*passwordData[i].IDs[j][9]));
            tempX2 = (gridCircMargin+(gridCircDistance*passwordData[i].IDs[j+1][7]));
            tempY2 = (gridCircMargin+(gridCircDistance*passwordData[i].IDs[j+1][9]));
            temporaryElement.setAttribute('stroke-width', gridStrokeWidth + "%");
            temporaryElement.setAttribute('stroke', currentColour);
            temporaryElement.setAttribute('x1', tempX1 + "%");
            temporaryElement.setAttribute('y1', tempY1 + "%");
            temporaryElement.setAttribute('x2', tempX2 + "%");
            temporaryElement.setAttribute('y2', tempY2 + "%");
            temporaryElement.classList.add("noclick");
            //draw an arrowhead if it's the last line
            if(j === passwordData[i].IDs.length-2) {
              temporaryElement.setAttribute('marker-end', "url(#arrowhead)");
            }
            htmlGrid.appendChild(temporaryElement);
          }
        } else if (passwordData[i].type === "arrow"){
          //draw an arrow
          temporaryElement = document.createElementNS("http://www.w3.org/2000/svg", "line");
          tempX1 = (gridCircMargin+(gridCircDistance*passwordData[i].idStart[7]));
          tempY1 = (gridCircMargin+(gridCircDistance*passwordData[i].idStart[9]));
          tempX2 = (gridCircMargin+(gridCircDistance*passwordData[i].idEnd[7]));
          tempY2 = (gridCircMargin+(gridCircDistance*passwordData[i].idEnd[9]));
          temporaryElement.setAttribute('stroke-width', gridStrokeWidth + "%");
          temporaryElement.setAttribute('stroke', currentColour);
          temporaryElement.setAttribute('x1', tempX1 + "%");
          temporaryElement.setAttribute('y1', tempY1 + "%");
          temporaryElement.setAttribute('x2', tempX2 + "%");
          temporaryElement.setAttribute('y2', tempY2 + "%");
          temporaryElement.setAttribute('marker-end', "url(#arrowhead)");
          temporaryElement.classList.add("noclick");
          htmlGrid.appendChild(temporaryElement);
        } else if (passwordData[i].type === "point") {
          //draw a point
          temporaryElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          temporaryElement.style.r = passwordDotRadius + "%";
          temporaryElement.style.fill = currentColour;
          tempFinalX = (gridCircMargin+(gridCircDistance*passwordData[i].id[7]));
          tempFinalY = (gridCircMargin+(gridCircDistance*passwordData[i].id[9]));
          temporaryElement.style.cx = tempFinalX + "%";
          temporaryElement.style.cy = tempFinalY + "%";
          temporaryElement.classList.add("noclick");
          htmlGrid.appendChild(temporaryElement);
        } else {
          console.log("draw_password - error: wrong object type");
        }
        ++lastDrawnPasswordObjects;
      }
    }

    //Object creator + Password creator
    function update_password_input(inputEvent, inputType){
      //debugging
      /*
      console.log(inputEvent.path[0].id);
      console.log(inputEvent.buttons);
      console.log(inputType);
      console.log("");
      */
      
      //Point and Arrow input
      if(inputType === "press"){
        //console.log("detected press")
        clickInputData[clickInputNodes] = [];
        clickInputData[clickInputNodes].type = "press";
        clickInputData[clickInputNodes].id = inputEvent.path[0].id;
        clickInputData[clickInputNodes].buttons = inputEvent.buttons;
        ++clickInputNodes;
      } else if (inputType === "release") {
        //console.log("detected release")
        //if the previous input was a press, and it is now released, it can only be a click
        if(clickInputData[clickInputNodes-1].type === "press"){
          if(clickInputData[clickInputNodes-1].id === inputEvent.path[0].id){
            clickInputData[clickInputNodes-1].type = "click";
            //console.log("saved click");
            //check if it is a point/arrow
            if(clickInputNodes >= 2 && clickInputData[clickInputNodes-2].type === "click"){
              if(clickInputData[clickInputNodes-2].id === inputEvent.path[0].id){
                clickInputData[clickInputNodes-2].type = "point";
                //store the arrow
                passwordData[passwordObjects] = [];
                passwordData[passwordObjects].type = "point";
                passwordData[passwordObjects].id = clickInputData[clickInputNodes-2].id;
                passwordData[passwordObjects].colour = currentColour;
                ++passwordObjects;
                clear_input();
                //reset the array for points/arrows
                clickInputNodes = 0;
                clickInputData = [];
                //console.log("Created Point");
              } else { //not the same id means it's an arrow
                clickInputData[clickInputNodes-2].type = "arrow";
                //store the arrow
                passwordData[passwordObjects] = [];
                passwordData[passwordObjects].type = "arrow";
                passwordData[passwordObjects].idStart = clickInputData[clickInputNodes-2].id;
                passwordData[passwordObjects].idEnd = inputEvent.path[0].id;
                passwordData[passwordObjects].colour = currentColour;
                ++passwordObjects;
                clear_input();
                //reset the array for points/arrows
                clickInputNodes = 0;
                clickInputData = [];
                //console.log("Created Arrow");
              }
            }
          }
        }
      }

      //Connected lines input
      if (inputType === "press" && connectedInputNodes == 0) {
        //press is the start of the input for connected lines
        connectedInputData[connectedInputNodes] = [];
        connectedInputData[connectedInputNodes].type = "press";
        connectedInputData[connectedInputNodes].id = inputEvent.path[0].id;
        ++connectedInputNodes;
        //console.log("press detected");
      } else if (inputType === "hover" && inputEvent.buttons === 1) {
        //do nothing if there's no input yet, as the start condition is a press
        if(connectedInputNodes !== 0) {
          //if it's the same node as last then it doesn't count as a new one
          if(connectedInputData[connectedInputNodes-1].id !== inputEvent.path[0].id){
            connectedInputData[connectedInputNodes] = [];
            connectedInputData[connectedInputNodes].type = "hover";
            connectedInputData[connectedInputNodes].id = inputEvent.path[0].id;
            ++connectedInputNodes;
            //console.log("hover detected"); 
          }
        }
      } else if (inputType === "release") {
        //check if the connected lines have been started
        if(connectedInputNodes >= 2) {
          //if the previous node is the same node then don't make "connected lines", and instead reset the array
          if(connectedInputData[connectedInputNodes-2].id !== inputEvent.path[0].id){
            passwordData[passwordObjects] = [];
            passwordData[passwordObjects].type = "connected lines";
            passwordData[passwordObjects].IDs = [];
            for(i = 0; i < connectedInputNodes; ++i){
              passwordData[passwordObjects].IDs[i] = connectedInputData[i].id;
            }
            passwordData[passwordObjects].colour = currentColour;
            ++passwordObjects;
            clear_input();
            connectedInputNodes = 0;
            connectedInputData = [];
            //console.log("release detected"); 
          } else {
            connectedInputNodes = 0;
            connectedInputData = [];
          }
        }
      }
      //update how the password is drawn
      draw_password();
    }




    //-------------------------------------------------cursor position updating-------------------------------------------------
    //from https://www.dev-notes.com/blog/2008/07/30/get-current-mouse-cursor-position-with-javascript/
    //Updates cursor position on mouse movement
    init();
    function init() {
      if (window.Event) {
        document.captureEvents(Event.MOUSEMOVE);
      }
      document.onmousemove = get_cursor_xy;
    }

    function get_cursor_xy(e) {
      mousePosXY[0] = (window.Event) ? e.pageX : event.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
      mousePosXY[1] = (window.Event) ? e.pageY : event.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
      //console.log("mouseX " + mousePosXY[0] + " mouseY " + mousePosXY[1])
      draw_object();
    }
    
    
  </script>


  <!-- Debugging cursor movement --> <!-- 
  <br /><br />
  <br /><br />
  <br /><br />
  <br /><br />
  <br /><br />
  <br /><br /> --> <!-- html go brrrr --> <!-- 
  <input type="text" id="cursorX" size="3"> X-position of the mouse cursor
  <br /><br />
  <input type="text" id="cursorY" size="3"> Y-position of the mouse cursor -->
</body>
</html>





